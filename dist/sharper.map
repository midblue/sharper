{"version":3,"sources":["scripts/log.js","app.js"],"names":["debug","process","env","DEBUG","minLength","resetColor","terminalColors","twoDigits","d","toString","module","exports","name","color","debugOnly","length","isBrowser","window","browserPrefix","args","log","undefined","prefix","colorCode","white","time","Date","timeStamp","getHours","getMinutes","getSeconds","sharp","require","fs","path","prompt","calledFromCommandLine","main","status","err","DEFAULT_SOURCE","DEFAULT_OUTPUT_FOLDER","promptSettings","runPrompt","get","enteredOptions","resizeProgrammatically","initializeResize","options","Promise","results","Array","isArray","promises","map","o","all","forEach","r","index","keys","key","push","Number","isInteger","checkOptions","resolve","messages","source","resized","success","fail","skipped","isImage","isFolder","detailsOfImagesToResize","detailsOfOutputFolderImages","parsedImagePath","exec","overwrite","getDataOfImageFilesInFolder","outputFolder","sourceDetails","removeDuplicateFiles","resizedImageDetails","resizeArrayOfImages","details","output","fileName","pop","message","width","parseInt","height","isNaN","replace","fileInfo","resizePromises","resizeImage","info","sourceImage","sourceDir","then","outputFolderFullPath","outputImageFullPath","createFolder","resize","max","toFile","catch","e","access","code","mkdir","getFilesInFolder","readdir","files","mkdirSync","getFilesInFolderAndCreatePathIfNecessary","parts","split","filter","p","currPath","pathEl","toRemoveFrom","comparison","fileData","find","comparisonData","anyData","start"],"mappings":"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","file":"sharper.map","sourceRoot":"..","sourcesContent":["const debug = process.env.DEBUG\nlet minLength = 1\nconst resetColor = '\\x1b[0m'\nconst terminalColors = {\n\tred: '\\x1b[31m',\n\tgreen: '\\x1b[32m',\n\tyellow: '\\x1b[33m',\n\tblue: '\\x1b[34m',\n\tmagenta: '\\x1b[35m',\n\tcyan: '\\x1b[36m',\n\twhite: '\\x1b[37m',\n}\n\nmodule.exports = function (name, color = 'green', debugOnly = false) {\n\tif (minLength < name.length + 1)\n\t\tminLength = name.length + 1\n\n\tconst isBrowser = typeof window !== 'undefined'\n\tlet browserPrefix = name + ' '\n\twhile (browserPrefix.length < minLength)\n\t\tbrowserPrefix += ' '\n\tbrowserPrefix += '| '\n\tif (isBrowser)\n\t\treturn (...args) => {\n\t\t\tconsole.log(`%c${browserPrefix}%c`, `color: ${color}`, `color: black`, ...args)\n\t\t}\n\n\tif (debugOnly && !debug) return () => undefined\n\treturn (...args) => {\n\t\tlet prefix = name + ' '\n\t\twhile (prefix.length < minLength)\n\t\t\tprefix += ' '\n\t\tprefix += '| '\n\t\tconst colorCode = terminalColors[color] || terminalColors.white\n\t\tconst time = new Date()\n\t\tconst timeStamp = twoDigits(time.getHours()) + ':' + twoDigits(time.getMinutes()) + ':' + twoDigits(time.getSeconds())\n\t\tconsole.log(colorCode + (timeStamp + ' '  + prefix) + resetColor, ...args)\n\t}\n}\n\nfunction twoDigits(d) {\n\tif (0 <= d && d < 10) return \"0\" + d.toString()\n\tif (-10 < d && d < 0) return \"-0\" + (-1 * d).toString()\n\treturn d.toString()\n}","const sharp = require('sharp')\nconst fs = require('fs')\nconst path = require('path')\nlet prompt\nconst calledFromCommandLine = require.main === module\nconst log = require('./scripts/log')\n\nconst status = log('success')\nconst err = log('error', 'red')\n\nconst DEFAULT_SOURCE = './'\nconst DEFAULT_OUTPUT_FOLDER = 'resized'\n\nconst promptSettings = {\n  properties: {\n    source: {\n      required: true,\n      default: DEFAULT_SOURCE\n    },\n    outputFolder: {\n      required: false,\n      default: DEFAULT_OUTPUT_FOLDER\n    },\n    width: {\n      pattern: /^\\d*$/,\n      message: 'Must be an integer',\n      type: 'integer',\n      required: false\n    },\n    height: {\n      pattern: /^\\d*$/,\n      message: 'Must be an integer',\n      type: 'integer',\n      required: false\n    },\n  }\n}\n\nif (calledFromCommandLine) {\n  prompt = require('prompt')\n  prompt.start()\n  runPrompt()\n}\n\nfunction runPrompt () {\n  prompt.get(promptSettings, async (err, enteredOptions) => {\n    if (err) return err(err)\n    await resizeProgrammatically(enteredOptions)\n    runPrompt()\n  })\n}\n\nfunction initializeResize (options) {\n  return new Promise (async resolve => {\n    let results\n    if (Array.isArray(options)) {\n      const promises = options.map(async o => await resizeProgrammatically(o))\n      results = await Promise.all(promises)\n      results.forEach((r, index) => {\n        if (index === 0) return\n        Object.keys(r).forEach(key => {\n          if (Array.isArray(r[key]))\n            results[0][key].push(...r[key])\n          else if (Number.isInteger(r[key]))\n            results[0][key] += r[key]\n        })\n      })\n      results = results[0]\n    }\n    else\n      results = await resizeProgrammatically(options)\n    resolve(results)\n    // could add watching here later, etc\n  })\n}\n\nfunction resizeProgrammatically (options) {\n  return new Promise(async resolve => {\n\n    options = checkOptions(options)\n    if (options.err) {\n      err(options.err)\n      return resolve(options)\n    }\n\n    const messages = []\n    const source = []\n    const resized = []\n    let success, fail, skipped\n\n    if (isImage(options.source) || isFolder(options.source)) {\n\n      let detailsOfImagesToResize = []\n      let detailsOfOutputFolderImages\n\n      if (isImage(options.source)) {\n        const parsedImagePath = /(.*\\/)?([^/]+\\.(?:jpe?g|png))$/gim.exec(options.source)\n        detailsOfImagesToResize.push({\n          sourceImage: path.resolve(parsedImagePath[0]),\n          sourceDir: path.resolve(parsedImagePath[1] || '.'),\n          fileName: parsedImagePath[2],\n        })\n        if (!options.overwrite)\n          detailsOfOutputFolderImages = await getDataOfImageFilesInFolder(path.resolve(parsedImagePath[1] || '.', options.outputFolder))\n      }\n\n      else {\n        const sourceDetails = await getDataOfImageFilesInFolder(options.source)\n        // need to check for returned error here\n        detailsOfImagesToResize.push(...sourceDetails)\n        if (!options.overwrite)\n          detailsOfOutputFolderImages = await getDataOfImageFilesInFolder(path.resolve(options.source, options.outputFolder))\n      }\n\n      skipped = detailsOfImagesToResize.length\n      if (!options.overwrite) {\n        // need to check for returned error here\n        detailsOfImagesToResize = removeDuplicateFiles(detailsOfImagesToResize, detailsOfOutputFolderImages)\n      }\n\n      const resizedImageDetails = await resizeArrayOfImages(detailsOfImagesToResize, { ...options })\n      success = resizedImageDetails.length\n      fail = detailsOfImagesToResize.length - success\n      skipped = skipped - success - fail\n\n      messages.push('Resized images:')\n      for (let details of resizedImageDetails) {\n        source.push(details.source)\n        resized.push(details.output)\n        messages.push(`   ${details.fileName}`)\n      }\n      if (resizedImageDetails.length === 0) {\n        messages.pop()\n      }\n      else\n        messages.push(`to ${path.resolve(options.source, options.outputFolder)}`)\n\n    }\n\n    else {\n      messages.push('Invalid path or image type.')\n      resolve ({ err: 'Invalid path or image type' })\n    }\n\n    if (messages.length > 0 && calledFromCommandLine) {\n      console.log('')\n      for (let message of messages)\n        status(message)\n      console.log('')\n    }\n\n    resolve({ source, resized, success, fail, skipped })\n\n  })\n}\n\nfunction checkOptions(options) {\n  options.width = parseInt(options.width)\n  options.height = parseInt(options.height)\n  if (isNaN(options.width)) delete options.width\n  if (isNaN(options.height)) delete options.height\n\n  if (options.overwrite !== true && options.overwrite !== false)\n    options.overwrite = false\n\n  options.source = (options.source || DEFAULT_SOURCE).replace(/\\s+$/g, '')\n  options.outputFolder = (options.outputFolder || DEFAULT_OUTPUT_FOLDER).replace(/^\\//g, '')\n\n  if (!options.width && !options.height)\n    return { err: 'Must specify at least one valid dimension' }\n  if (options.width <= 0 || options.height <= 0)\n    return { err: 'Invalid width or height value.' }\n  if (options.source.length === 0)\n    options.source = './'\n\n  return options\n}\n\nfunction resizeArrayOfImages(fileInfo, options) {\n  return new Promise (async resolve => {\n    const resizePromises = fileInfo\n      .map(async info => await resizeImage({\n        ...options,\n        fileName: info.fileName,\n        sourceImage: info.sourceImage,\n        sourceDir: info.sourceDir\n      }))\n\n    Promise.all(resizePromises)\n      .then((fileInfo) => resolve(fileInfo))\n  })\n}\n\nasync function resizeImage({ sourceImage, sourceDir, fileName, width, height, outputFolder }) {\n  const outputFolderFullPath = path.resolve(sourceDir, outputFolder)\n  const outputImageFullPath = outputFolderFullPath + '/' + fileName\n\n  await createFolder(outputFolderFullPath)\n\n  return sharp(sourceImage)\n    .resize(width, height)\n    .max()\n    .toFile(outputImageFullPath)\n    .then(() => {\n      return {\n        source: path.resolve(sourceImage),\n        fileName,\n        output: outputImageFullPath,\n      }\n    })\n    .catch(e => err(e))\n}\n\nfunction createFolder (path) {\n  return new Promise (resolve => {\n    fs.access(path, (err) => {\n      if (err && err.code !== 'EEXIST') {\n        fs.mkdir(path, () => {\n          resolve()\n        })\n      }\n      else resolve ()\n    })\n  })\n}\n\nfunction getFilesInFolder (path) {\n  return new Promise(resolve => {\n    fs.readdir(path, (e, files) => {\n      if (e) {\n        try { fs.mkdirSync(path) }\n        catch (e) {}\n        resolve([])\n      }\n      else resolve(files)\n    })\n  })\n}\n\nasync function getFilesInFolderAndCreatePathIfNecessary (path) {\n  const parts = path.split('/').filter(p => p)\n  let currPath = '', files\n  for (let pathEl of parts) {\n    currPath += pathEl + '/'\n    files = await getFilesInFolder(currPath)\n  }\n  return files\n}\n\nfunction getDataOfImageFilesInFolder (sourceDir) {\n  return new Promise (async resolve => {\n    if (!/.*\\/$/g.exec(sourceDir))\n      sourceDir += '/'\n\n    let files = await getFilesInFolderAndCreatePathIfNecessary(sourceDir)\n    if (!Array.isArray(files)) //err\n      return resolve(files)\n\n    files = files\n      .filter(path => isImage(path))\n      .map(fileName => ({\n          sourceImage: sourceDir + fileName,\n          fileName,\n          sourceDir,\n        })\n      )\n\n    resolve(files)\n  })\n}\n\nfunction removeDuplicateFiles (toRemoveFrom, comparison) {\n  return toRemoveFrom\n    .map(fileData => \n      comparison.find(comparisonData => \n        fileData.fileName === comparisonData.fileName\n      ) ? null : fileData\n    )\n    .filter(anyData => anyData)\n}\n\nfunction isImage (path) {\n  return /.+\\.(?:jpe?g|png)$/gi.exec(path)\n}\nfunction isFolder (path) {\n  return /^(\\.*\\/)?(?:([^/\\n])*\\/)*([^/.\\n])*\\/?$|^.$/gi.exec(path)\n}\n\nmodule.exports = initializeResize"]}